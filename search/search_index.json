{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"postmodal","text":"<p>Postprocessing of modal parameters from structural dynamics.</p>"},{"location":"modules/","title":"Modules","text":""},{"location":"modules/#core-types","title":"Core Types","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"modules/#postmodal.types","title":"<code>postmodal.types</code>","text":"<p>Custom types and data classes for modal analysis.</p>"},{"location":"modules/#postmodal.types.ComplexityMetrics","title":"<code>ComplexityMetrics</code>  <code>dataclass</code>","text":"<p>Container for modal complexity metrics.</p> <p>Attributes:</p> Name Type Description <code>mpc</code> <code>ndarray</code> <p>Modal Phase Collinearity values [n_modes]</p> <code>map</code> <code>ndarray</code> <p>Modal Amplitude Proportionality values [n_modes]</p> <code>mpd</code> <code>ndarray</code> <p>Mean Phase Deviation values [n_modes] in degrees</p> Source code in <code>postmodal/types.py</code> <pre><code>@dataclass\nclass ComplexityMetrics:\n    \"\"\"Container for modal complexity metrics.\n\n    Attributes\n    ----------\n    mpc : np.ndarray\n        Modal Phase Collinearity values [n_modes]\n    map : np.ndarray\n        Modal Amplitude Proportionality values [n_modes]\n    mpd : np.ndarray\n        Mean Phase Deviation values [n_modes] in degrees\n    \"\"\"\n\n    mpc: np.ndarray\n    map: np.ndarray\n    mpd: np.ndarray\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the metrics after initialization.\"\"\"\n        shapes = [\n            self.mpc.shape,\n            self.map.shape,\n            self.mpd.shape,\n        ]\n        if not all(s == shapes[0] for s in shapes):\n            raise ValueError(\"All metrics must have the same shape\")\n</code></pre>"},{"location":"modules/#postmodal.types.ComplexityMetrics.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"<p>Validate the metrics after initialization.</p> Source code in <code>postmodal/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the metrics after initialization.\"\"\"\n    shapes = [\n        self.mpc.shape,\n        self.map.shape,\n        self.mpd.shape,\n    ]\n    if not all(s == shapes[0] for s in shapes):\n        raise ValueError(\"All metrics must have the same shape\")\n</code></pre>"},{"location":"modules/#postmodal.types.ModalData","title":"<code>ModalData</code>  <code>dataclass</code>","text":"<p>Container for modal analysis data.</p> <p>Attributes:</p> Name Type Description <code>frequencies</code> <code>ndarray</code> <p>Array of natural frequencies [n_modes]. Must be positive real values.</p> <code>modeshapes</code> <code>ndarray</code> <p>Array of mode shapes [n_modes x n_dof]</p> <code>damping</code> <code>(ndarray, optional)</code> <p>Array of damping ratios [n_modes], defaults to zeros. Must be real-valued positive numbers in range [0, 1].</p> Source code in <code>postmodal/types.py</code> <pre><code>@dataclass\nclass ModalData:\n    \"\"\"Container for modal analysis data.\n\n    Attributes\n    ----------\n    frequencies : np.ndarray\n        Array of natural frequencies [n_modes]. Must be positive real values.\n    modeshapes : np.ndarray\n        Array of mode shapes [n_modes x n_dof]\n    damping : np.ndarray, optional\n        Array of damping ratios [n_modes], defaults to zeros.\n        Must be real-valued positive numbers in range [0, 1].\n    \"\"\"\n\n    frequencies: np.ndarray\n    modeshapes: np.ndarray\n    damping: np.ndarray | None = field(default_factory=lambda: np.array([]))\n\n    def _validate_frequencies(self) -&gt; None:\n        \"\"\"Validate frequency data.\"\"\"\n        if not isinstance(self.frequencies, np.ndarray):\n            raise TypeError(\"frequencies must be a numpy array\")\n        if not np.isreal(self.frequencies).all():\n            raise ValueError(\"frequencies must be real-valued\")\n        if np.any(self.frequencies &lt;= 0):\n            raise ValueError(\"frequencies must be positive\")\n\n    def _validate_modeshapes(self) -&gt; None:\n        \"\"\"Validate modeshape data.\"\"\"\n        if not isinstance(self.modeshapes, np.ndarray):\n            raise TypeError(\"modeshapes must be a numpy array\")\n        if self.modeshapes.ndim not in [1, 2]:\n            raise ValueError(\"modeshapes must be 1D or 2D array\")\n        if self.frequencies.shape[0] != self.modeshapes.shape[0]:\n            raise ValueError(\"Number of frequencies must match number of modes\")\n\n    def _validate_damping(self) -&gt; None:\n        \"\"\"Validate damping data.\"\"\"\n        if self.damping is None or len(self.damping) == 0:\n            self.damping = np.zeros_like(self.frequencies)\n            return\n\n        if not isinstance(self.damping, np.ndarray):\n            raise TypeError(\"damping must be a numpy array\")\n        if not np.isreal(self.damping).all():\n            raise ValueError(\"damping must be real-valued\")\n        if self.damping.shape != self.frequencies.shape:\n            raise ValueError(\"damping must have same shape as frequencies\")\n        if np.any(self.damping &lt; 0):\n            raise ValueError(\"damping ratios must be non-negative\")\n        if np.any(self.damping &gt; 1):\n            raise ValueError(\"damping ratios must be less than or equal to 1\")\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the data after initialization.\"\"\"\n        self._validate_frequencies()\n        self._validate_modeshapes()\n        self._validate_damping()\n</code></pre>"},{"location":"modules/#postmodal.types.ModalData.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"<p>Validate the data after initialization.</p> Source code in <code>postmodal/types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the data after initialization.\"\"\"\n    self._validate_frequencies()\n    self._validate_modeshapes()\n    self._validate_damping()\n</code></pre>"},{"location":"modules/#validation","title":"Validation","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"modules/#postmodal.validation","title":"<code>postmodal.validation</code>","text":"<p>Validation utilities for modal analysis data.</p>"},{"location":"modules/#postmodal.validation.ModalValidator","title":"<code>ModalValidator</code>","text":"<p>Validator for modeshape data.</p> Source code in <code>postmodal/validation.py</code> <pre><code>class ModalValidator:\n    \"\"\"Validator for modeshape data.\"\"\"\n\n    @staticmethod\n    def validate(modeshape: np.ndarray) -&gt; None:\n        \"\"\"Validate a modeshape array.\n\n        Parameters\n        ----------\n        modeshape : np.ndarray\n            The modeshape array to validate\n\n        Raises\n        ------\n        TypeError\n            If modeshape is not a numpy array\n        ValueError\n            If modeshape has incorrect dimensions\n        \"\"\"\n        if not isinstance(modeshape, np.ndarray):\n            raise TypeError(\"Modeshape must be a numpy array\")\n        if modeshape.ndim not in [1, 2]:\n            raise ValueError(\"Modeshape must be 1D or 2D array\")\n        if modeshape.size == 0:\n            raise ValueError(\"Modeshape array cannot be empty\")\n\n    @staticmethod\n    def validate_pair(phi_1: np.ndarray, phi_2: np.ndarray) -&gt; None:\n        \"\"\"Validate a pair of modeshapes for comparison.\n\n        Parameters\n        ----------\n        phi_1 : np.ndarray\n            First modeshape\n        phi_2 : np.ndarray\n            Second modeshape\n\n        Raises\n        ------\n        ValueError\n            If modeshapes have different shapes\n        \"\"\"\n        # Validate individual modeshapes first\n        ModalValidator.validate(phi_1)\n        ModalValidator.validate(phi_2)\n        if phi_1.shape != phi_2.shape:\n            raise ValueError(\"Modeshapes must have the same shape\")\n\n    @staticmethod\n    def validate_frequency(frequency: np.ndarray) -&gt; None:\n        \"\"\"Validate frequency data.\n\n        Parameters\n        ----------\n        frequency : np.ndarray\n            Array of frequencies to validate\n\n        Raises\n        ------\n        TypeError\n            If frequency is not a numpy array\n        ValueError\n            If frequency is not 1D or contains non-positive values\n        \"\"\"\n        if not isinstance(frequency, np.ndarray):\n            raise TypeError(\"Frequency must be a numpy array\")\n        if frequency.ndim != 1:\n            raise ValueError(\"Frequency must be 1D array\")\n        if np.any(frequency &lt;= 0):\n            raise ValueError(\"All frequencies must be positive\")\n</code></pre>"},{"location":"modules/#postmodal.validation.ModalValidator.validate","title":"<code>validate(modeshape: np.ndarray) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Validate a modeshape array.</p> <p>Parameters:</p> Name Type Description Default <code>modeshape</code> <code>ndarray</code> <p>The modeshape array to validate</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If modeshape is not a numpy array</p> <code>ValueError</code> <p>If modeshape has incorrect dimensions</p> Source code in <code>postmodal/validation.py</code> <pre><code>@staticmethod\ndef validate(modeshape: np.ndarray) -&gt; None:\n    \"\"\"Validate a modeshape array.\n\n    Parameters\n    ----------\n    modeshape : np.ndarray\n        The modeshape array to validate\n\n    Raises\n    ------\n    TypeError\n        If modeshape is not a numpy array\n    ValueError\n        If modeshape has incorrect dimensions\n    \"\"\"\n    if not isinstance(modeshape, np.ndarray):\n        raise TypeError(\"Modeshape must be a numpy array\")\n    if modeshape.ndim not in [1, 2]:\n        raise ValueError(\"Modeshape must be 1D or 2D array\")\n    if modeshape.size == 0:\n        raise ValueError(\"Modeshape array cannot be empty\")\n</code></pre>"},{"location":"modules/#postmodal.validation.ModalValidator.validate_frequency","title":"<code>validate_frequency(frequency: np.ndarray) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Validate frequency data.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>ndarray</code> <p>Array of frequencies to validate</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If frequency is not a numpy array</p> <code>ValueError</code> <p>If frequency is not 1D or contains non-positive values</p> Source code in <code>postmodal/validation.py</code> <pre><code>@staticmethod\ndef validate_frequency(frequency: np.ndarray) -&gt; None:\n    \"\"\"Validate frequency data.\n\n    Parameters\n    ----------\n    frequency : np.ndarray\n        Array of frequencies to validate\n\n    Raises\n    ------\n    TypeError\n        If frequency is not a numpy array\n    ValueError\n        If frequency is not 1D or contains non-positive values\n    \"\"\"\n    if not isinstance(frequency, np.ndarray):\n        raise TypeError(\"Frequency must be a numpy array\")\n    if frequency.ndim != 1:\n        raise ValueError(\"Frequency must be 1D array\")\n    if np.any(frequency &lt;= 0):\n        raise ValueError(\"All frequencies must be positive\")\n</code></pre>"},{"location":"modules/#postmodal.validation.ModalValidator.validate_pair","title":"<code>validate_pair(phi_1: np.ndarray, phi_2: np.ndarray) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Validate a pair of modeshapes for comparison.</p> <p>Parameters:</p> Name Type Description Default <code>phi_1</code> <code>ndarray</code> <p>First modeshape</p> required <code>phi_2</code> <code>ndarray</code> <p>Second modeshape</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If modeshapes have different shapes</p> Source code in <code>postmodal/validation.py</code> <pre><code>@staticmethod\ndef validate_pair(phi_1: np.ndarray, phi_2: np.ndarray) -&gt; None:\n    \"\"\"Validate a pair of modeshapes for comparison.\n\n    Parameters\n    ----------\n    phi_1 : np.ndarray\n        First modeshape\n    phi_2 : np.ndarray\n        Second modeshape\n\n    Raises\n    ------\n    ValueError\n        If modeshapes have different shapes\n    \"\"\"\n    # Validate individual modeshapes first\n    ModalValidator.validate(phi_1)\n    ModalValidator.validate(phi_2)\n    if phi_1.shape != phi_2.shape:\n        raise ValueError(\"Modeshapes must have the same shape\")\n</code></pre>"},{"location":"modules/#postmodal.validation.validate_modal_data","title":"<code>validate_modal_data(frequencies: np.ndarray, modeshapes: np.ndarray) -&gt; None</code>","text":"<p>Validate modal data (frequencies and modeshapes).</p> <p>Parameters:</p> Name Type Description Default <code>frequencies</code> <code>ndarray</code> <p>Array of natural frequencies [n_modes]</p> required <code>modeshapes</code> <code>ndarray</code> <p>Array of mode shapes [n_modes x n_dof]</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If data dimensions are incompatible</p> Source code in <code>postmodal/validation.py</code> <pre><code>def validate_modal_data(frequencies: np.ndarray, modeshapes: np.ndarray) -&gt; None:\n    \"\"\"Validate modal data (frequencies and modeshapes).\n\n    Parameters\n    ----------\n    frequencies : np.ndarray\n        Array of natural frequencies [n_modes]\n    modeshapes : np.ndarray\n        Array of mode shapes [n_modes x n_dof]\n\n    Raises\n    ------\n    ValueError\n        If data dimensions are incompatible\n    \"\"\"\n    ModalValidator.validate(modeshapes)\n    ModalValidator.validate_frequency(frequencies)\n\n    if frequencies.shape[0] != modeshapes.shape[0]:\n        raise ValueError(\"Number of frequencies must match number of modes\")\n</code></pre>"},{"location":"modules/#complexity-metrics","title":"Complexity Metrics","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"modules/#postmodal.complexity","title":"<code>postmodal.complexity</code>","text":"<p>Functions for calculating modal complexity metrics.</p>"},{"location":"modules/#postmodal.complexity.calculate_complexity_metrics","title":"<code>calculate_complexity_metrics(modeshape: np.ndarray) -&gt; ComplexityMetrics</code>","text":"<p>Calculate all complexity metrics for a modeshape or set of modeshapes.</p> <p>This function computes all available complexity metrics: - Modal Phase Collinearity (MPC) - Modal Amplitude Proportionality (MAP) - Mean Phase Deviation (MPD)</p> <p>Parameters:</p> Name Type Description Default <code>modeshape</code> <code>ndarray</code> <p>Single modeshape [n_dof] or set of modeshapes [n_modes x n_dof]. Can be real or complex-valued.</p> required <p>Returns:</p> Type Description <code>ComplexityMetrics</code> <p>Container with all computed complexity metrics. Each metric has shape [] for single modeshape or [n_modes] for multiple modeshapes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If modeshape has incorrect dimensions</p> Source code in <code>postmodal/complexity.py</code> <pre><code>def calculate_complexity_metrics(modeshape: np.ndarray) -&gt; ComplexityMetrics:\n    \"\"\"Calculate all complexity metrics for a modeshape or set of modeshapes.\n\n    This function computes all available complexity metrics:\n    - Modal Phase Collinearity (MPC)\n    - Modal Amplitude Proportionality (MAP)\n    - Mean Phase Deviation (MPD)\n\n    Parameters\n    ----------\n    modeshape : np.ndarray\n        Single modeshape [n_dof] or set of modeshapes [n_modes x n_dof].\n        Can be real or complex-valued.\n\n    Returns\n    -------\n    ComplexityMetrics\n        Container with all computed complexity metrics.\n        Each metric has shape [] for single modeshape or [n_modes] for multiple modeshapes.\n\n    Raises\n    ------\n    ValueError\n        If modeshape has incorrect dimensions\n    \"\"\"\n    ModalValidator.validate(modeshape)\n\n    # Calculate all metrics\n    mpc_values = calculate_mpc(modeshape)\n    map_values = calculate_map(modeshape)\n    mpd_values = calculate_mpd(modeshape)\n\n    # Return as ComplexityMetrics container\n    return ComplexityMetrics(\n        mpc=mpc_values,\n        map=map_values,\n        mpd=mpd_values,\n    )\n</code></pre>"},{"location":"modules/#postmodal.complexity.calculate_map","title":"<code>calculate_map(modeshape: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Calculate Modal Amplitude Proportionality (MAP) for a modeshape or set of modeshapes.</p> <p>MAP assesses the amplitude proportionality of a complex mode shape. A higher MAP value (\u2248 1) indicates that the mode shape amplitudes are largely proportional to their real parts, suggesting a more 'real' amplitude distribution. A lower MAP value (&lt; 1) indicates a deviation from real amplitude proportionality, suggesting a more complex amplitude distribution and significant imaginary components.</p> Math: <p>.. math::     MAP_r = \\frac{ \\sum_{j=1}^{n} |Re(\\Phi_{jr})| }{ \\sum_{j=1}^{n} |\\Phi_{jr}| }</p> <p>Where: - :math:<code>\\Phi_{jr}</code>: j-th component of the r-th complex mode shape. - :math:<code>Re(\\Phi_{jr})</code>: Real part of :math:<code>\\Phi_{jr}</code>. - :math:<code>n</code>: Number of DOFs. - :math:<code>| ... |</code>: Magnitude (absolute value for scalar, modulus for complex).</p> <p>Parameters:</p> Name Type Description Default <code>modeshape</code> <code>ndarray</code> <p>Single modeshape [n_dof] or set of modeshapes [n_modes x n_dof]. Can be real or complex-valued.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>MAP value(s). - Scalar if input is a single modeshape []. - 1D array [n_modes] if input is a set of modeshapes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input <code>modeshape</code> is not a NumPy array.</p> <code>NotImplementedError</code> <p>If the input <code>modeshape</code> has dimensions other than 1 or 2.</p> Source code in <code>postmodal/complexity.py</code> <pre><code>def calculate_map(modeshape: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Calculate Modal Amplitude Proportionality (MAP) for a modeshape or set of modeshapes.\n\n    MAP assesses the amplitude proportionality of a complex mode shape.\n    A higher MAP value (\u2248 1) indicates that the mode shape amplitudes are largely\n    proportional to their real parts, suggesting a more 'real' amplitude distribution.\n    A lower MAP value (&lt; 1) indicates a deviation from real amplitude proportionality,\n    suggesting a more complex amplitude distribution and significant imaginary components.\n\n    Math:\n    -----\n    .. math::\n        MAP_r = \\\\frac{ \\\\sum_{j=1}^{n} |Re(\\\\Phi_{jr})| }{ \\\\sum_{j=1}^{n} |\\\\Phi_{jr}| }\n\n    Where:\n    - :math:`\\\\Phi_{jr}`: j-th component of the r-th complex mode shape.\n    - :math:`Re(\\\\Phi_{jr})`: Real part of :math:`\\\\Phi_{jr}`.\n    - :math:`n`: Number of DOFs.\n    - :math:`| ... |`: Magnitude (absolute value for scalar, modulus for complex).\n\n    Parameters\n    ----------\n    modeshape : np.ndarray\n        Single modeshape [n_dof] or set of modeshapes [n_modes x n_dof].\n        Can be real or complex-valued.\n\n    Returns\n    -------\n    np.ndarray\n        MAP value(s).\n        - Scalar if input is a single modeshape [].\n        - 1D array [n_modes] if input is a set of modeshapes.\n\n    Raises\n    ------\n    ValueError\n        If the input `modeshape` is not a NumPy array.\n    NotImplementedError\n        If the input `modeshape` has dimensions other than 1 or 2.\n    \"\"\"\n    ModalValidator.validate(modeshape)\n\n    if modeshape.ndim == 1:\n        numerator = np.sum(np.abs(modeshape.real))\n        denominator = np.sum(np.abs(modeshape))\n        map_value = numerator / denominator if denominator != 0 else 0.0  # Handle potential division by zero\n        return np.array(map_value)  # Return as 0D array for consistency\n\n    elif modeshape.ndim == 2:\n        map_values = []\n        for mode in modeshape:\n            numerator = np.sum(np.abs(mode.real))\n            denominator = np.sum(np.abs(mode))\n            map_value = numerator / denominator if denominator != 0 else 0.0  # Handle potential division by zero\n            map_values.append(map_value)\n        return np.array(map_values)\n\n    else:\n        raise NotImplementedError(f\"modeshape has dimensions: {modeshape.ndim}, expecting 1 or 2.\")\n</code></pre>"},{"location":"modules/#postmodal.complexity.calculate_mpc","title":"<code>calculate_mpc(modeshape: np.ndarray, method: str = 'mac') -&gt; np.ndarray</code>","text":"<p>Calculate Modal Phase Collinearity (MPC) for a modeshape or set of modeshapes.</p> <p>MPC quantifies the 'realness' of a mode shape by measuring the phase alignment of its components. A higher MPC value (\u2248 1) indicates a more 'real' mode shape with phases close to 0\u00b0 or 180\u00b0, suggesting proportionally damped or undamped behavior. A lower MPC value (\u2248 0) suggests a more complex mode shape with scattered phases, indicating non-proportional damping or mode coupling.</p> Math: <p>.. math::     MPC(\\phi_j) = \\frac{||Re(\\tilde{\\phi}j)||_2^2 + ||Im(\\tilde{\\phi}_j)||_2^2}     {||Re(\\tilde{\\phi}_j)||_2^2 + \\epsilon{MPC}^{-1} Re(\\tilde{\\phi}j^T)Im(\\tilde{\\phi}_j)     (2(\\epsilon{MPC}^2 + 1)\\sin^2(\\theta_{MPC}) - 1)}</p> <p>Where: - :math:<code>\\tilde{\\phi}_j</code>: Centered mode shape - :math:<code>\\epsilon_{MPC}</code>: MPC epsilon parameter - :math:<code>\\theta_{MPC}</code>: MPC angle parameter - :math:<code>||...||_2^2</code>: Squared L2 norm</p> <p>Parameters:</p> Name Type Description Default <code>modeshape</code> <code>ndarray</code> <p>Single modeshape [n_dof] or set of modeshapes [n_modes x n_dof]. Can be real or complex-valued.</p> required <code>method</code> <code>str</code> <p>Method to use for MPC calculation: - \"old\": Original implementation using epsilon and theta parameters - \"eigenvalue\": Implementation using eigenvalue decomposition - \"mac\": Implementation using Modal Assurance Criterion formula (default)</p> <code>'mac'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>MPC value(s). - Scalar if input is a single modeshape []. - 1D array [n_modes] if input is a set of modeshapes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input <code>modeshape</code> is not a NumPy array or if method is invalid.</p> <code>NotImplementedError</code> <p>If the input <code>modeshape</code> has dimensions other than 1 or 2.</p> Source code in <code>postmodal/complexity.py</code> <pre><code>def calculate_mpc(modeshape: np.ndarray, method: str = \"mac\") -&gt; np.ndarray:\n    \"\"\"Calculate Modal Phase Collinearity (MPC) for a modeshape or set of modeshapes.\n\n    MPC quantifies the 'realness' of a mode shape by measuring the phase alignment\n    of its components. A higher MPC value (\u2248 1) indicates a more 'real' mode shape\n    with phases close to 0\u00b0 or 180\u00b0, suggesting proportionally damped or undamped behavior.\n    A lower MPC value (\u2248 0) suggests a more complex mode shape with scattered phases,\n    indicating non-proportional damping or mode coupling.\n\n    Math:\n    -----\n    .. math::\n        MPC(\\\\phi_j) = \\\\frac{||Re(\\\\tilde{\\\\phi}_j)||_2^2 + ||Im(\\\\tilde{\\\\phi}_j)||_2^2}\n        {||Re(\\\\tilde{\\\\phi}_j)||_2^2 + \\\\epsilon_{MPC}^{-1} Re(\\\\tilde{\\\\phi}_j^T)Im(\\\\tilde{\\\\phi}_j)\n        (2(\\\\epsilon_{MPC}^2 + 1)\\\\sin^2(\\\\theta_{MPC}) - 1)}\n\n    Where:\n    - :math:`\\\\tilde{\\\\phi}_j`: Centered mode shape\n    - :math:`\\\\epsilon_{MPC}`: MPC epsilon parameter\n    - :math:`\\\\theta_{MPC}`: MPC angle parameter\n    - :math:`||...||_2^2`: Squared L2 norm\n\n    Parameters\n    ----------\n    modeshape : np.ndarray\n        Single modeshape [n_dof] or set of modeshapes [n_modes x n_dof].\n        Can be real or complex-valued.\n    method : str, optional\n        Method to use for MPC calculation:\n        - \"old\": Original implementation using epsilon and theta parameters\n        - \"eigenvalue\": Implementation using eigenvalue decomposition\n        - \"mac\": Implementation using Modal Assurance Criterion formula (default)\n\n    Returns\n    -------\n    np.ndarray\n        MPC value(s).\n        - Scalar if input is a single modeshape [].\n        - 1D array [n_modes] if input is a set of modeshapes.\n\n    Raises\n    ------\n    ValueError\n        If the input `modeshape` is not a NumPy array or if method is invalid.\n    NotImplementedError\n        If the input `modeshape` has dimensions other than 1 or 2.\n    \"\"\"\n    ModalValidator.validate(modeshape)\n\n    if method not in [\"old\", \"eigenvalue\", \"mac\"]:\n        raise ValueError('method must be one of \"old\", \"eigenvalue\", or \"mac\"')\n\n    calculate_single_mpc = {\n        \"old\": _calculate_mpc_old,\n        \"eigenvalue\": _calculate_mpc_eigvals,\n        \"mac\": _calculate_mpc_mac,\n    }[method]\n\n    if modeshape.ndim == 1:\n        return np.array(calculate_single_mpc(modeshape))\n    elif modeshape.ndim == 2:\n        return np.array([calculate_single_mpc(mode) for mode in modeshape])\n    else:\n        raise NotImplementedError(f\"modeshape has dimensions: {modeshape.ndim}, expecting 1 or 2.\")\n</code></pre>"},{"location":"modules/#postmodal.complexity.calculate_mpd","title":"<code>calculate_mpd(modeshape: np.ndarray, weights: str = 'magnitude') -&gt; np.ndarray</code>","text":"<p>Calculate Mean Phase Deviation (MPD) for a modeshape or set of modeshapes.</p> <p>MPD quantifies the phase scatter within a mode shape by measuring the weighted average of phase deviations from the mean phase angle. The mean phase is determined by solving a total least squares problem using SVD to find the best straight line fit through the mode shape in the complex plane.</p> Math: <p>.. math::     MP(\\phi_j) = \\arctan\\left(\\frac{-V_{12}}{V_{22}}\\right)</p> <pre><code>MPD(\\phi_j) = \\frac{\\sum_{o=1}^{n_y} w_o \\arccos\\left|\\frac{Re(\\phi_{jo})V_{22} - Im(\\phi_{jo})V_{12}}{\\sqrt{V_{12}^2 + V_{22}^2}|\\phi_{jo}|}\\right|}{\\sum_{o=1}^{n_y} w_o}\n</code></pre> <p>Where: - :math:<code>MP(\\phi_j)</code>: Mean phase angle determined by SVD - :math:<code>V_{12}, V_{22}</code>: Elements of the V matrix from SVD of [Re(\u03c6j) Im(\u03c6j)] - :math:<code>w_o</code>: Weighting factors (either |\u03c6jo| or 1 for equal weights) - :math:<code>\\phi_{jo}</code>: Complex mode shape components - :math:<code>n_y</code>: Number of DOFs</p> <p>Parameters:</p> Name Type Description Default <code>modeshape</code> <code>ndarray</code> <p>Single modeshape [n_dof] or set of modeshapes [n_modes x n_dof]. Can be real or complex-valued.</p> required <code>weights</code> <code>str</code> <p>Weighting scheme for phase deviations: - \"magnitude\": weights are the magnitude of each mode shape component (default) - \"equal\": equal weights for all components</p> <code>'magnitude'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>MPD value(s) in degrees. - Scalar if input is a single modeshape []. - 1D array [n_modes] if input is a set of modeshapes.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the input <code>modeshape</code> is not a NumPy array.</p> <code>NotImplementedError</code> <p>If the input <code>modeshape</code> has dimensions other than 1 or 2.</p> <code>ValueError</code> <p>If <code>weights</code> is not one of \"magnitude\" or \"equal\".</p> Source code in <code>postmodal/complexity.py</code> <pre><code>def calculate_mpd(modeshape: np.ndarray, weights: str = \"magnitude\") -&gt; np.ndarray:\n    \"\"\"Calculate Mean Phase Deviation (MPD) for a modeshape or set of modeshapes.\n\n    MPD quantifies the phase scatter within a mode shape by measuring the weighted average\n    of phase deviations from the mean phase angle. The mean phase is determined by solving\n    a total least squares problem using SVD to find the best straight line fit through\n    the mode shape in the complex plane.\n\n    Math:\n    -----\n    .. math::\n        MP(\\\\phi_j) = \\\\arctan\\\\left(\\\\frac{-V_{12}}{V_{22}}\\\\right)\n\n        MPD(\\\\phi_j) = \\\\frac{\\\\sum_{o=1}^{n_y} w_o \\\\arccos\\\\left|\\\\frac{Re(\\\\phi_{jo})V_{22} - Im(\\\\phi_{jo})V_{12}}{\\\\sqrt{V_{12}^2 + V_{22}^2}|\\\\phi_{jo}|}\\\\right|}{\\\\sum_{o=1}^{n_y} w_o}\n\n    Where:\n    - :math:`MP(\\\\phi_j)`: Mean phase angle determined by SVD\n    - :math:`V_{12}, V_{22}`: Elements of the V matrix from SVD of [Re(\u03c6j) Im(\u03c6j)]\n    - :math:`w_o`: Weighting factors (either |\u03c6jo| or 1 for equal weights)\n    - :math:`\\\\phi_{jo}`: Complex mode shape components\n    - :math:`n_y`: Number of DOFs\n\n    Parameters\n    ----------\n    modeshape : np.ndarray\n        Single modeshape [n_dof] or set of modeshapes [n_modes x n_dof].\n        Can be real or complex-valued.\n    weights : str, optional\n        Weighting scheme for phase deviations:\n        - \"magnitude\": weights are the magnitude of each mode shape component (default)\n        - \"equal\": equal weights for all components\n\n    Returns\n    -------\n    np.ndarray\n        MPD value(s) in degrees.\n        - Scalar if input is a single modeshape [].\n        - 1D array [n_modes] if input is a set of modeshapes.\n\n    Raises\n    ------\n    TypeError\n        If the input `modeshape` is not a NumPy array.\n    NotImplementedError\n        If the input `modeshape` has dimensions other than 1 or 2.\n    ValueError\n        If `weights` is not one of \"magnitude\" or \"equal\".\n    \"\"\"\n    if not isinstance(modeshape, np.ndarray):\n        raise TypeError(\"Input modeshape must be a NumPy array.\")\n\n    if weights not in [\"magnitude\", \"equal\"]:\n        raise ValueError('weights must be either \"magnitude\" or \"equal\"')\n\n    def calculate_single_mpd(mode: np.ndarray) -&gt; float:\n        # Form matrix with real and imaginary parts\n        A = np.column_stack((mode.real, mode.imag))\n\n        # Compute SVD\n        U, S, Vh = np.linalg.svd(A)\n        V = Vh.T  # Convert to V matrix\n\n        # Extract V12 and V22\n        V12, V22 = V[0, 1], V[1, 1]\n\n        # Calculate weights based on chosen scheme\n        if weights == \"magnitude\":\n            weights_array = np.abs(mode).astype(np.float64)\n        else:  # equal weights\n            weights_array = np.ones(len(mode), dtype=np.float64)\n\n        # Calculate denominator term\n        denom_term = np.sqrt(V12**2 + V22**2)\n\n        # Calculate phase deviations for each component\n        phase_deviations = np.zeros(len(mode), dtype=np.float64)\n        for i, (phi, w) in enumerate(zip(mode, weights_array, strict=False)):\n            if w == 0:  # Skip zero components\n                continue\n\n            # Calculate numerator term\n            num_term = (phi.real * V22 - phi.imag * V12) / (denom_term * w)\n\n            # Ensure argument is in [-1, 1] for arccos\n            num_term = np.clip(num_term, -1.0, 1.0)\n\n            # Calculate phase deviation\n            phase_deviations[i] = np.arccos(np.abs(num_term))\n\n        # Calculate weighted average\n        if np.sum(weights_array) == 0:\n            return 0.0\n\n        mpd_radians = float(np.sum(weights_array * phase_deviations) / np.sum(weights_array))\n        return float(np.degrees(mpd_radians))\n\n    if modeshape.ndim == 1:\n        return np.array(calculate_single_mpd(modeshape))\n    elif modeshape.ndim == 2:\n        return np.array([calculate_single_mpd(mode) for mode in modeshape])\n    else:\n        raise NotImplementedError(f\"modeshape has dimensions: {modeshape.ndim}, expecting 1 or 2.\")\n</code></pre>"},{"location":"modules/#comparison","title":"Comparison","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"modules/#postmodal.comparison","title":"<code>postmodal.comparison</code>","text":"<p>Modal comparison module.</p>"},{"location":"modules/#postmodal.comparison.best_match","title":"<code>best_match(match_matrix: np.ndarray, threshold: float = 0.6) -&gt; tuple[int, int] | None</code>","text":"<p>Find indices of best matching mode below threshold.</p> <p>This function finds the pair of modes with the lowest matching value that is still below the specified threshold. It is used internally by match_modes.</p> <p>Parameters:</p> Name Type Description Default <code>match_matrix</code> <code>ndarray</code> <p>Matching matrix [n_modes_1 x n_modes_2] where lower values indicate better matches</p> required <code>threshold</code> <code>float</code> <p>Threshold for acceptable matches, by default 0.6</p> <code>0.6</code> <p>Returns:</p> Type Description <code>Optional[Tuple[int, int]]</code> <p>Indices of best match, or None if no match below threshold</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If matrix contains non-positive values or is not 2D</p> Source code in <code>postmodal/comparison/matrix.py</code> <pre><code>def best_match(match_matrix: np.ndarray, threshold: float = 0.6) -&gt; tuple[int, int] | None:\n    \"\"\"Find indices of best matching mode below threshold.\n\n    This function finds the pair of modes with the lowest matching value that is\n    still below the specified threshold. It is used internally by match_modes.\n\n    Parameters\n    ----------\n    match_matrix : np.ndarray\n        Matching matrix [n_modes_1 x n_modes_2] where lower values indicate better matches\n    threshold : float, optional\n        Threshold for acceptable matches, by default 0.6\n\n    Returns\n    -------\n    Optional[Tuple[int, int]]\n        Indices of best match, or None if no match below threshold\n\n    Raises\n    ------\n    ValueError\n        If matrix contains non-positive values or is not 2D\n    \"\"\"\n    if not np.all(match_matrix &gt; 0.0):\n        raise ValueError(\"All matrix values must be positive\")\n    if match_matrix.ndim != 2:\n        raise ValueError(\"Matrix must be 2D\")\n\n    if not np.any(match_matrix &lt;= threshold):\n        return None\n\n    indices = np.unravel_index(np.argmin(match_matrix, axis=None), match_matrix.shape)\n    return (int(indices[0]), int(indices[1]))\n</code></pre>"},{"location":"modules/#postmodal.comparison.calculate_mac","title":"<code>calculate_mac(phi_1: np.ndarray, phi_2: np.ndarray) -&gt; float</code>","text":"<p>Calculate the MAC value of two (complex) modeshape vectors.</p> <p>The Modal Assurance Criterion (MAC) is a measure of the correlation between two mode shapes. A MAC value close to 1 indicates strong correlation between the mode shapes, while a value close to 0 indicates weak correlation.</p> Math: <p>.. math::     MAC = \\frac{ |\\phi_1^H \\phi_2|^2 }{ (\\phi_1^H \\phi_1)(\\phi_2^H \\phi_2) }</p> <p>Where: - :math:<code>\\phi_1, \\phi_2</code>: Complex mode shape vectors - :math:<code>^H</code>: Hermitian transpose - :math:<code>|...|</code>: Magnitude of complex number</p> <p>Parameters:</p> Name Type Description Default <code>phi_1</code> <code>ndarray</code> <p>First modeshape vector [n_dof]</p> required <code>phi_2</code> <code>ndarray</code> <p>Second modeshape vector [n_dof]</p> required <p>Returns:</p> Type Description <code>float</code> <p>MAC value between 0 and 1</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If modeshapes have different shapes</p> Source code in <code>postmodal/comparison/mac.py</code> <pre><code>def calculate_mac(phi_1: np.ndarray, phi_2: np.ndarray) -&gt; float:\n    \"\"\"Calculate the MAC value of two (complex) modeshape vectors.\n\n    The Modal Assurance Criterion (MAC) is a measure of the correlation between\n    two mode shapes. A MAC value close to 1 indicates strong correlation between\n    the mode shapes, while a value close to 0 indicates weak correlation.\n\n    Math:\n    -----\n    .. math::\n        MAC = \\\\frac{ |\\\\phi_1^H \\\\phi_2|^2 }{ (\\\\phi_1^H \\\\phi_1)(\\\\phi_2^H \\\\phi_2) }\n\n    Where:\n    - :math:`\\\\phi_1, \\\\phi_2`: Complex mode shape vectors\n    - :math:`^H`: Hermitian transpose\n    - :math:`|...|`: Magnitude of complex number\n\n    Parameters\n    ----------\n    phi_1 : np.ndarray\n        First modeshape vector [n_dof]\n    phi_2 : np.ndarray\n        Second modeshape vector [n_dof]\n\n    Returns\n    -------\n    float\n        MAC value between 0 and 1\n\n    Raises\n    ------\n    ValueError\n        If modeshapes have different shapes\n    \"\"\"\n    ModalValidator.validate_pair(phi_1, phi_2)\n\n    numerator = np.abs(np.vdot(phi_1, phi_2)) ** 2\n    denominator = np.vdot(phi_1, phi_1) * np.vdot(phi_2, phi_2)\n    return float((numerator / denominator).real)\n</code></pre>"},{"location":"modules/#postmodal.comparison.calculate_mac_matrix","title":"<code>calculate_mac_matrix(phi_1: np.ndarray, phi_2: np.ndarray) -&gt; NDArray</code>","text":"<p>Calculate the MAC matrix between two sets of modeshapes.</p> <p>The Modal Assurance Criterion (MAC) matrix quantifies the correlation between all pairs of mode shapes from two sets. Each element (i,j) represents the MAC value between mode i from the first set and mode j from the second set.</p> Math: <p>.. math::     MAC_{ij} = \\frac{ |\\phi_{1i}^H \\phi_{2j}|^2 }{ (\\phi_{1i}^H \\phi_{1i})(\\phi_{2j}^H \\phi_{2j}) }</p> <p>Where: - :math:<code>\\phi_{1i}</code>: i-th mode shape from first set - :math:<code>\\phi_{2j}</code>: j-th mode shape from second set - :math:<code>^H</code>: Hermitian transpose - :math:<code>|...|</code>: Magnitude of complex number</p> <p>Parameters:</p> Name Type Description Default <code>phi_1</code> <code>ndarray</code> <p>First set of modeshapes [n_modes_1 x n_dof]</p> required <code>phi_2</code> <code>ndarray</code> <p>Second set of modeshapes [n_modes_2 x n_dof]</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>MAC matrix [n_modes_1 x n_modes_2] with values between 0 and 1</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If modeshapes have different shapes</p> Source code in <code>postmodal/comparison/matrix.py</code> <pre><code>def calculate_mac_matrix(phi_1: np.ndarray, phi_2: np.ndarray) -&gt; NDArray:\n    \"\"\"Calculate the MAC matrix between two sets of modeshapes.\n\n    The Modal Assurance Criterion (MAC) matrix quantifies the correlation between\n    all pairs of mode shapes from two sets. Each element (i,j) represents the MAC\n    value between mode i from the first set and mode j from the second set.\n\n    Math:\n    -----\n    .. math::\n        MAC_{ij} = \\\\frac{ |\\\\phi_{1i}^H \\\\phi_{2j}|^2 }{ (\\\\phi_{1i}^H \\\\phi_{1i})(\\\\phi_{2j}^H \\\\phi_{2j}) }\n\n    Where:\n    - :math:`\\\\phi_{1i}`: i-th mode shape from first set\n    - :math:`\\\\phi_{2j}`: j-th mode shape from second set\n    - :math:`^H`: Hermitian transpose\n    - :math:`|...|`: Magnitude of complex number\n\n    Parameters\n    ----------\n    phi_1 : np.ndarray\n        First set of modeshapes [n_modes_1 x n_dof]\n    phi_2 : np.ndarray\n        Second set of modeshapes [n_modes_2 x n_dof]\n\n    Returns\n    -------\n    NDArray\n        MAC matrix [n_modes_1 x n_modes_2] with values between 0 and 1\n\n    Raises\n    ------\n    ValueError\n        If modeshapes have different shapes\n    \"\"\"\n    ModalValidator.validate_pair(phi_1, phi_2)\n\n    # discern between real and complex modes\n    # numpy.vdot cannot be used here, since\n    # \"it should only be used for vectors.\"\n    # https://numpy.org/doc/stable/reference/generated/numpy.vdot.html\n    if np.iscomplexobj(phi_1) or np.iscomplexobj(phi_2):\n        return cast(\n            NDArray,\n            np.square(\n                np.abs(np.dot(phi_1, phi_2.conj().T))\n                / (np.linalg.norm(phi_1, axis=1)[:, np.newaxis] * np.linalg.norm(phi_2, axis=1))\n            ),\n        )\n    else:\n        return cast(\n            NDArray,\n            np.square(\n                np.abs(np.dot(phi_1, phi_2.T))\n                / (np.linalg.norm(phi_1, axis=1)[:, np.newaxis] * np.linalg.norm(phi_2, axis=1))\n            ),\n        )\n</code></pre>"},{"location":"modules/#postmodal.comparison.calculate_mode_matching_matrix","title":"<code>calculate_mode_matching_matrix(frequencies_1: np.ndarray, modeshapes_1: np.ndarray, frequencies_2: np.ndarray, modeshapes_2: np.ndarray, modeshape_weight: float = 1.0) -&gt; NDArray</code>","text":"<p>Calculate mode matching matrix considering frequency and MAC.</p> <p>Based on Simoen et al., 2014, \"Dealing with uncertainty in model updating in damage assessment\". The matching matrix combines frequency differences and MAC values to find corresponding modes between two sets. A lower value indicates a better match.</p> Math: <p>.. math::     M_{ij} = w(1 - MAC_{ij}) + |1 - f_{1i}/f_{2j}|</p> <p>Where: - :math:<code>MAC_{ij}</code>: MAC value between modes i and j - :math:<code>f_{1i}</code>: Frequency of mode i from first set - :math:<code>f_{2j}</code>: Frequency of mode j from second set - :math:<code>w</code>: Weight for modeshape contribution</p> <p>Parameters:</p> Name Type Description Default <code>frequencies_1</code> <code>ndarray</code> <p>Frequencies of first set [n_modes_1]</p> required <code>modeshapes_1</code> <code>ndarray</code> <p>Modeshapes of first set [n_modes_1 x n_dof]</p> required <code>frequencies_2</code> <code>ndarray</code> <p>Frequencies of second set [n_modes_2]</p> required <code>modeshapes_2</code> <code>ndarray</code> <p>Modeshapes of second set [n_modes_2 x n_dof]</p> required <code>modeshape_weight</code> <code>float</code> <p>Weight for modeshape contribution, by default 1.0</p> <code>1.0</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Matching matrix [n_modes_1 x n_modes_2] where lower values indicate better matches</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input arrays have incompatible shapes</p> Source code in <code>postmodal/comparison/matrix.py</code> <pre><code>def calculate_mode_matching_matrix(\n    frequencies_1: np.ndarray,\n    modeshapes_1: np.ndarray,\n    frequencies_2: np.ndarray,\n    modeshapes_2: np.ndarray,\n    modeshape_weight: float = 1.0,\n) -&gt; NDArray:\n    \"\"\"Calculate mode matching matrix considering frequency and MAC.\n\n    Based on Simoen et al., 2014, \"Dealing with uncertainty in model updating in damage assessment\".\n    The matching matrix combines frequency differences and MAC values to find corresponding modes\n    between two sets. A lower value indicates a better match.\n\n    Math:\n    -----\n    .. math::\n        M_{ij} = w(1 - MAC_{ij}) + |1 - f_{1i}/f_{2j}|\n\n    Where:\n    - :math:`MAC_{ij}`: MAC value between modes i and j\n    - :math:`f_{1i}`: Frequency of mode i from first set\n    - :math:`f_{2j}`: Frequency of mode j from second set\n    - :math:`w`: Weight for modeshape contribution\n\n    Parameters\n    ----------\n    frequencies_1 : np.ndarray\n        Frequencies of first set [n_modes_1]\n    modeshapes_1 : np.ndarray\n        Modeshapes of first set [n_modes_1 x n_dof]\n    frequencies_2 : np.ndarray\n        Frequencies of second set [n_modes_2]\n    modeshapes_2 : np.ndarray\n        Modeshapes of second set [n_modes_2 x n_dof]\n    modeshape_weight : float, optional\n        Weight for modeshape contribution, by default 1.0\n\n    Returns\n    -------\n    NDArray\n        Matching matrix [n_modes_1 x n_modes_2] where lower values indicate better matches\n\n    Raises\n    ------\n    ValueError\n        If input arrays have incompatible shapes\n    \"\"\"\n    mac_matrix = calculate_mac_matrix(modeshapes_1, modeshapes_2)\n    freq_matrix = np.abs(1 - frequencies_1[:, np.newaxis] / frequencies_2[np.newaxis, :])\n\n    return cast(NDArray, modeshape_weight * (1 - mac_matrix) + freq_matrix)\n</code></pre>"},{"location":"modules/#postmodal.comparison.match_modes","title":"<code>match_modes(match_matrix: np.ndarray, threshold: float = 0.6) -&gt; tuple[Sequence[int], Sequence[int]]</code>","text":"<p>Find best matching modes using matching matrix.</p> <p>This function finds pairs of modes that best match based on the matching matrix. It uses a greedy approach to find the best matches below the specified threshold. Each mode can only be matched once.</p> <p>Parameters:</p> Name Type Description Default <code>match_matrix</code> <code>ndarray</code> <p>Matching matrix [n_modes_1 x n_modes_2] where lower values indicate better matches</p> required <code>threshold</code> <code>float</code> <p>Threshold for acceptable matches, by default 0.6</p> <code>0.6</code> <p>Returns:</p> Type Description <code>Tuple[Sequence[int], Sequence[int]]</code> <p>Indices of matching modes from first and second set</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If matrix contains non-positive values or is not 2D</p> Source code in <code>postmodal/comparison/matrix.py</code> <pre><code>def match_modes(match_matrix: np.ndarray, threshold: float = 0.6) -&gt; tuple[Sequence[int], Sequence[int]]:\n    \"\"\"Find best matching modes using matching matrix.\n\n    This function finds pairs of modes that best match based on the matching matrix.\n    It uses a greedy approach to find the best matches below the specified threshold.\n    Each mode can only be matched once.\n\n    Parameters\n    ----------\n    match_matrix : np.ndarray\n        Matching matrix [n_modes_1 x n_modes_2] where lower values indicate better matches\n    threshold : float, optional\n        Threshold for acceptable matches, by default 0.6\n\n    Returns\n    -------\n    Tuple[Sequence[int], Sequence[int]]\n        Indices of matching modes from first and second set\n\n    Raises\n    ------\n    ValueError\n        If matrix contains non-positive values or is not 2D\n    \"\"\"\n    if not np.all(match_matrix &gt; 0.0):\n        raise ValueError(\"All matrix values must be positive\")\n    if match_matrix.ndim != 2:\n        raise ValueError(\"Matrix must be 2D\")\n\n    n_modes_1, n_modes_2 = match_matrix.shape\n    n_modes_min = min(n_modes_1, n_modes_2)\n\n    _match_matrix = match_matrix.copy()\n    matching_modes_1 = []\n    matching_modes_2 = []\n\n    for _ in range(n_modes_min):\n        match = best_match(_match_matrix, threshold)\n        if match is None:\n            break\n\n        matching_modes_1.append(match[0])\n        matching_modes_2.append(match[1])\n\n        # Mark matched modes\n        _match_matrix[match[0], :] = threshold + 1.0\n        _match_matrix[:, match[1]] = threshold + 1.0\n\n    return tuple(matching_modes_1), tuple(matching_modes_2)\n</code></pre>"},{"location":"modules/#manipulation","title":"Manipulation","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"modules/#postmodal.manipulation","title":"<code>postmodal.manipulation</code>","text":"<p>Modeshape manipulation utilities.</p> <p>This module provides functions for manipulating modeshapes, including normalization, phase alignment, and complex-to-real conversion.</p> <p>.. note::    The :func:<code>normalize_modeshape</code> function is deprecated and will be removed in a future version.    Use :func:<code>normalize_modeshape_unit_norm_vector_length</code> instead.</p>"},{"location":"modules/#postmodal.manipulation.align_phase","title":"<code>align_phase(modeshape: NDArray[np.complex128], reference_dof: int | None = None) -&gt; NDArray[np.complex128]</code>","text":"<p>Align the phase of a modeshape to a reference DOF.</p> <p>This function aligns the phase of a modeshape by rotating it so that the phase at a reference DOF is zero. If no reference DOF is specified, the DOF that minimizes the phase range is used.</p> <p>Parameters:</p> Name Type Description Default <code>modeshape</code> <code>ndarray</code> <p>Complex modeshape array [n_dof]</p> required <code>reference_dof</code> <code>Optional[int]</code> <p>Index of the reference DOF, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Phase-aligned modeshape [n_dof]</p> Notes <p>The phase alignment is achieved by multiplying the modeshape by :math:<code>e^{-i\\phi_{ref}}</code>, where :math:<code>\\phi_{ref}</code> is the phase angle at the reference DOF.</p> Source code in <code>postmodal/manipulation/phase.py</code> <pre><code>def align_phase(\n    modeshape: NDArray[np.complex128],\n    reference_dof: int | None = None,\n) -&gt; NDArray[np.complex128]:\n    \"\"\"Align the phase of a modeshape to a reference DOF.\n\n    This function aligns the phase of a modeshape by rotating it so that\n    the phase at a reference DOF is zero. If no reference DOF is specified,\n    the DOF that minimizes the phase range is used.\n\n    Parameters\n    ----------\n    modeshape : np.ndarray\n        Complex modeshape array [n_dof]\n    reference_dof : Optional[int], optional\n        Index of the reference DOF, by default None\n\n    Returns\n    -------\n    np.ndarray\n        Phase-aligned modeshape [n_dof]\n\n    Notes\n    -----\n    The phase alignment is achieved by multiplying the modeshape by\n    :math:`e^{-i\\\\phi_{ref}}`, where :math:`\\\\phi_{ref}` is the phase\n    angle at the reference DOF.\n    \"\"\"\n    if reference_dof is not None:\n        # Use specified reference DOF\n        phase_ref = np.angle(modeshape[reference_dof])\n        return cast(NDArray[np.complex128], modeshape * np.exp(-1j * phase_ref))\n\n    # Find DOF that minimizes phase range\n    phases = np.angle(modeshape)\n    min_range = float(\"inf\")\n    best_ref_dof = 0\n\n    for i in range(len(modeshape)):\n        # Try each DOF as reference\n        aligned_phases = phases - phases[i]\n        # Normalize to [-\u03c0, \u03c0]\n        aligned_phases = np.mod(aligned_phases + np.pi, 2 * np.pi) - np.pi\n        phase_range = np.max(aligned_phases) - np.min(aligned_phases)\n\n        if phase_range &lt; min_range:\n            min_range = phase_range\n            best_ref_dof = i\n\n    # Align using the best reference DOF\n    phase_ref = phases[best_ref_dof]\n    return cast(NDArray[np.complex128], modeshape * np.exp(-1j * phase_ref))\n</code></pre>"},{"location":"modules/#postmodal.manipulation.calculate_conversion_error","title":"<code>calculate_conversion_error(complex_modeshape: np.ndarray, real_modeshape: np.ndarray) -&gt; tuple[float, float]</code>","text":"<p>Calculate the error between complex and real modeshapes.</p> <p>This function computes two error metrics: 1. Magnitude error: Relative difference in magnitudes 2. Phase error: Average absolute phase difference</p> <p>Parameters:</p> Name Type Description Default <code>complex_modeshape</code> <code>ndarray</code> <p>Original complex modeshape [n_dof]</p> required <code>real_modeshape</code> <code>ndarray</code> <p>Converted real modeshape [n_dof]</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>Tuple containing (magnitude_error, phase_error) - magnitude_error: Relative difference in magnitudes - phase_error: Average absolute phase difference in radians</p> Source code in <code>postmodal/manipulation/complex_to_real.py</code> <pre><code>def calculate_conversion_error(\n    complex_modeshape: np.ndarray,\n    real_modeshape: np.ndarray,\n) -&gt; tuple[float, float]:\n    \"\"\"Calculate the error between complex and real modeshapes.\n\n    This function computes two error metrics:\n    1. Magnitude error: Relative difference in magnitudes\n    2. Phase error: Average absolute phase difference\n\n    Parameters\n    ----------\n    complex_modeshape : np.ndarray\n        Original complex modeshape [n_dof]\n    real_modeshape : np.ndarray\n        Converted real modeshape [n_dof]\n\n    Returns\n    -------\n    tuple[float, float]\n        Tuple containing (magnitude_error, phase_error)\n        - magnitude_error: Relative difference in magnitudes\n        - phase_error: Average absolute phase difference in radians\n    \"\"\"\n    # Calculate magnitude error\n    complex_mag = np.abs(complex_modeshape)\n    real_mag = np.abs(real_modeshape)\n    magnitude_error = np.mean(np.abs(complex_mag - real_mag) / complex_mag)\n\n    # Calculate phase error\n    complex_phase = np.angle(complex_modeshape)\n    real_phase = np.angle(real_modeshape)\n    phase_error = np.mean(np.abs(complex_phase - real_phase))\n\n    return magnitude_error, phase_error\n</code></pre>"},{"location":"modules/#postmodal.manipulation.calculate_phase_distribution","title":"<code>calculate_phase_distribution(modeshape: NDArray[np.complex128], bins: int = 36) -&gt; tuple[NDArray[np.int_], NDArray[np.float64]]</code>","text":"<p>Calculate the phase angle distribution of a modeshape.</p> <p>This function computes a histogram of phase angles in the modeshape, which can be useful for analyzing phase clustering and identifying dominant phase patterns.</p> <p>Parameters:</p> Name Type Description Default <code>modeshape</code> <code>ndarray</code> <p>Complex modeshape array [n_dof]</p> required <code>bins</code> <code>int</code> <p>Number of bins for the histogram, by default 36</p> <code>36</code> <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>Tuple containing (histogram, bin_edges) - histogram: Array of phase angle counts - bin_edges: Array of bin edges in radians</p> Source code in <code>postmodal/manipulation/phase.py</code> <pre><code>def calculate_phase_distribution(\n    modeshape: NDArray[np.complex128],\n    bins: int = 36,\n) -&gt; tuple[NDArray[np.int_], NDArray[np.float64]]:\n    \"\"\"Calculate the phase angle distribution of a modeshape.\n\n    This function computes a histogram of phase angles in the modeshape,\n    which can be useful for analyzing phase clustering and identifying\n    dominant phase patterns.\n\n    Parameters\n    ----------\n    modeshape : np.ndarray\n        Complex modeshape array [n_dof]\n    bins : int, optional\n        Number of bins for the histogram, by default 36\n\n    Returns\n    -------\n    tuple[np.ndarray, np.ndarray]\n        Tuple containing (histogram, bin_edges)\n        - histogram: Array of phase angle counts\n        - bin_edges: Array of bin edges in radians\n    \"\"\"\n    phase = np.angle(modeshape)\n    hist, edges = np.histogram(phase, bins=bins, range=(-np.pi, np.pi))\n    return hist, edges\n</code></pre>"},{"location":"modules/#postmodal.manipulation.complex_to_real_batch","title":"<code>complex_to_real_batch(modeshapes: np.ndarray, method: str = 'phase', reference_dof: int | None = None) -&gt; np.ndarray</code>","text":"<p>Convert a batch of complex modeshapes to real-valued modeshapes.</p> <p>This function converts multiple complex modeshapes to real-valued modeshapes using the specified method.</p> <p>Parameters:</p> Name Type Description Default <code>modeshapes</code> <code>ndarray</code> <p>Array of complex modeshapes [n_modes x n_dof]</p> required <code>method</code> <code>str</code> <p>Conversion method, by default \"phase\"</p> <code>'phase'</code> <code>reference_dof</code> <code>Optional[int]</code> <p>Index of the reference DOF for phase alignment, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of real-valued modeshapes [n_modes x n_dof]</p> See Also <p>complex_to_real : Convert a single complex modeshape</p> Source code in <code>postmodal/manipulation/complex_to_real.py</code> <pre><code>def complex_to_real_batch(\n    modeshapes: np.ndarray,\n    method: str = \"phase\",\n    reference_dof: int | None = None,\n) -&gt; np.ndarray:\n    \"\"\"Convert a batch of complex modeshapes to real-valued modeshapes.\n\n    This function converts multiple complex modeshapes to real-valued modeshapes\n    using the specified method.\n\n    Parameters\n    ----------\n    modeshapes : np.ndarray\n        Array of complex modeshapes [n_modes x n_dof]\n    method : str, optional\n        Conversion method, by default \"phase\"\n    reference_dof : Optional[int], optional\n        Index of the reference DOF for phase alignment, by default None\n\n    Returns\n    -------\n    np.ndarray\n        Array of real-valued modeshapes [n_modes x n_dof]\n\n    See Also\n    --------\n    complex_to_real : Convert a single complex modeshape\n    \"\"\"\n    # Explicitly cast the result to np.ndarray to satisfy the return type\n    return np.array([complex_to_real(phi, method, reference_dof) for phi in modeshapes])\n</code></pre>"},{"location":"modules/#postmodal.manipulation.normalize_modeshape","title":"<code>normalize_modeshape(modeshape: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Normalize a single modeshape or set of modeshapes (real part only).</p> <p>.. deprecated:: 1.0.0    Use :func:<code>normalize_modeshape_unit_norm_vector_length</code> instead, which supports both real and complex modeshapes.    This function will be removed in a future version.</p> <p>This function normalizes only the real part of the modeshape(s) to unit norm. For a single modeshape, the 2-norm is used. For multiple modeshapes, each modeshape is normalized independently.</p> <p>Parameters:</p> Name Type Description Default <code>modeshape</code> <code>ndarray</code> <p>Single modeshape [n_dof] or set of modeshapes [n_modes x n_dof]</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Normalized modeshape(s) with the same shape as input</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If modeshape has incorrect dimensions</p> Source code in <code>postmodal/manipulation/normalize.py</code> <pre><code>def normalize_modeshape(modeshape: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Normalize a single modeshape or set of modeshapes (real part only).\n\n    .. deprecated:: 1.0.0\n       Use :func:`normalize_modeshape_unit_norm_vector_length` instead, which supports both real and complex modeshapes.\n       This function will be removed in a future version.\n\n    This function normalizes only the real part of the modeshape(s) to unit norm.\n    For a single modeshape, the 2-norm is used.\n    For multiple modeshapes, each modeshape is normalized independently.\n\n    Parameters\n    ----------\n    modeshape : np.ndarray\n        Single modeshape [n_dof] or set of modeshapes [n_modes x n_dof]\n\n    Returns\n    -------\n    np.ndarray\n        Normalized modeshape(s) with the same shape as input\n\n    Raises\n    ------\n    ValueError\n        If modeshape has incorrect dimensions\n    \"\"\"\n    warnings.warn(\n        \"normalize_modeshape is deprecated and will be removed in a future version. \"\n        \"Use normalize_modeshape_unit_norm_vector_length instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    ModalValidator.validate(modeshape)\n    return normalize_modeshape_unit_norm_vector_length(modeshape.real)\n</code></pre>"},{"location":"modules/#postmodal.manipulation.normalize_modeshape_reference_dof","title":"<code>normalize_modeshape_reference_dof(modeshape: np.ndarray, ref_dof_index: int) -&gt; np.ndarray</code>","text":"<p>Normalize a single modeshape or set of modeshapes using a reference degree of freedom (DOF).</p> <p>This normalization method scales each mode shape vector such that the component at the specified reference DOF index is normalized to unity (value of 1). This is useful when you want to scale mode shapes relative to a specific point on the structure, often a sensor location in experimental modal analysis. Works for both real and complex mode shapes.</p> Math: <p>For a mode shape :math:<code>\\vec{\\Phi}_r</code> and a chosen reference DOF index <code>k</code> (ref_dof_index), the normalized mode shape :math:<code>\\vec{\\Phi}_{r, normalized}</code> is:</p> <p>.. math::     \\vec{\\Phi}{r, normalized} = \\frac{\\vec{\\Phi}_r}{\\Phi{kr}}</p> <p>Where :math:<code>\\Phi_{kr}</code> is the component of the mode shape vector at the reference DOF index <code>k</code>.</p> <p>Parameters:</p> Name Type Description Default <code>modeshape</code> <code>ndarray</code> <p>Single modeshape [n_dof] or set of modeshapes [n_modes x n_dof]. Can be real or complex-valued.</p> required <code>ref_dof_index</code> <code>int</code> <p>Index of the reference degree of freedom (0-indexed). Must be a valid index within the modeshape dimension (0 &lt;= ref_dof_index &lt; n_dof).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Normalized modeshape(s) with the same shape as input. Each mode shape will have value 1 at the reference DOF.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If modeshape has incorrect dimensions or ref_dof_index is invalid</p> Source code in <code>postmodal/manipulation/normalize.py</code> <pre><code>def normalize_modeshape_reference_dof(modeshape: np.ndarray, ref_dof_index: int) -&gt; np.ndarray:\n    \"\"\"Normalize a single modeshape or set of modeshapes using a reference degree of freedom (DOF).\n\n    This normalization method scales each mode shape vector such that the component at the specified\n    reference DOF index is normalized to unity (value of 1). This is useful when you want to scale mode shapes\n    relative to a specific point on the structure, often a sensor location in experimental modal analysis.\n    Works for both real and complex mode shapes.\n\n    Math:\n    -----\n    For a mode shape :math:`\\\\vec{\\\\Phi}_r` and a chosen reference DOF index `k` (ref_dof_index),\n    the normalized mode shape :math:`\\\\vec{\\\\Phi}_{r, normalized}` is:\n\n    .. math::\n        \\\\vec{\\\\Phi}_{r, normalized} = \\\\frac{\\\\vec{\\\\Phi}_r}{\\\\Phi_{kr}}\n\n    Where :math:`\\\\Phi_{kr}` is the component of the mode shape vector at the reference DOF index `k`.\n\n    Parameters\n    ----------\n    modeshape : np.ndarray\n        Single modeshape [n_dof] or set of modeshapes [n_modes x n_dof].\n        Can be real or complex-valued.\n    ref_dof_index : int\n        Index of the reference degree of freedom (0-indexed).\n        Must be a valid index within the modeshape dimension (0 &lt;= ref_dof_index &lt; n_dof).\n\n    Returns\n    -------\n    np.ndarray\n        Normalized modeshape(s) with the same shape as input.\n        Each mode shape will have value 1 at the reference DOF.\n\n    Raises\n    ------\n    ValueError\n        If modeshape has incorrect dimensions or ref_dof_index is invalid\n    \"\"\"\n    ModalValidator.validate(modeshape)\n\n    if not isinstance(ref_dof_index, int):\n        raise TypeError(\"ref_dof_index must be an integer\")\n\n    if modeshape.ndim == 1:\n        if not 0 &lt;= ref_dof_index &lt; modeshape.shape[0]:\n            raise ValueError(\n                f\"ref_dof_index {ref_dof_index} is out of bounds for modeshape of length {modeshape.shape[0]}\"\n            )\n        ref_val = modeshape[ref_dof_index]\n        return modeshape / ref_val if ref_val != 0 else modeshape\n\n    # modeshape.ndim == 2\n    if not 0 &lt;= ref_dof_index &lt; modeshape.shape[1]:\n        raise ValueError(f\"ref_dof_index {ref_dof_index} is out of bounds for modeshape with {modeshape.shape[1]} DOFs\")\n    ref_vals = modeshape[:, ref_dof_index]\n    return np.where(ref_vals[:, np.newaxis] != 0, modeshape / ref_vals[:, np.newaxis], modeshape)\n</code></pre>"},{"location":"modules/#postmodal.manipulation.normalize_modeshape_unit_norm_max_amplitude","title":"<code>normalize_modeshape_unit_norm_max_amplitude(modeshape: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Normalize a single modeshape or set of modeshapes to unit norm (maximum amplitude).</p> <p>This normalization method scales each mode shape vector such that the component with the maximum absolute value is normalized to unity (magnitude of 1). This method emphasizes the largest displacement component and is useful when you want to scale mode shapes based on their peak amplitude. Works for both real and complex mode shapes.</p> Math: <p>For a mode shape :math:<code>\\vec{\\Phi}_r</code>, let :math:<code>\\Phi_{max, r}</code> be the component with the maximum absolute value in :math:<code>\\vec{\\Phi}_r</code>. The normalized mode shape :math:<code>\\vec{\\Phi}_{r, normalized}</code> is:</p> <p>.. math::     \\vec{\\Phi}{r, normalized} = \\frac{\\vec{\\Phi}_r}{\\Phi{max, r}}</p> <p>Note: In case of multiple components having the same maximum magnitude, the first encountered component with maximum magnitude is used as the reference.</p> <p>Parameters:</p> Name Type Description Default <code>modeshape</code> <code>ndarray</code> <p>Single modeshape [n_dof] or set of modeshapes [n_modes x n_dof]. Can be real or complex-valued.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Normalized modeshape(s) with the same shape as input. Each mode shape will have maximum amplitude of 1.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If modeshape has incorrect dimensions</p> Source code in <code>postmodal/manipulation/normalize.py</code> <pre><code>def normalize_modeshape_unit_norm_max_amplitude(modeshape: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Normalize a single modeshape or set of modeshapes to unit norm (maximum amplitude).\n\n    This normalization method scales each mode shape vector such that the component with the maximum absolute\n    value is normalized to unity (magnitude of 1). This method emphasizes the largest displacement component and\n    is useful when you want to scale mode shapes based on their peak amplitude. Works for both real and complex mode shapes.\n\n    Math:\n    -----\n    For a mode shape :math:`\\\\vec{\\\\Phi}_r`, let :math:`\\\\Phi_{max, r}` be the component with the maximum absolute value in :math:`\\\\vec{\\\\Phi}_r`.\n    The normalized mode shape :math:`\\\\vec{\\\\Phi}_{r, normalized}` is:\n\n    .. math::\n        \\\\vec{\\\\Phi}_{r, normalized} = \\\\frac{\\\\vec{\\\\Phi}_r}{\\\\Phi_{max, r}}\n\n    Note: In case of multiple components having the same maximum magnitude, the first encountered component with maximum magnitude is used as the reference.\n\n    Parameters\n    ----------\n    modeshape : np.ndarray\n        Single modeshape [n_dof] or set of modeshapes [n_modes x n_dof].\n        Can be real or complex-valued.\n\n    Returns\n    -------\n    np.ndarray\n        Normalized modeshape(s) with the same shape as input.\n        Each mode shape will have maximum amplitude of 1.\n\n    Raises\n    ------\n    ValueError\n        If modeshape has incorrect dimensions\n    \"\"\"\n    ModalValidator.validate(modeshape)\n\n    if modeshape.ndim == 1:\n        max_val = np.max(np.abs(modeshape))\n        return modeshape / max_val if max_val != 0 else modeshape\n\n    # modeshape.ndim == 2\n    max_vals = np.max(np.abs(modeshape), axis=1)\n    return np.where(max_vals[:, np.newaxis] != 0, modeshape / max_vals[:, np.newaxis], modeshape)\n</code></pre>"},{"location":"modules/#postmodal.manipulation.normalize_modeshape_unit_norm_vector_length","title":"<code>normalize_modeshape_unit_norm_vector_length(modeshape: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Normalize a single modeshape or set of modeshapes to unit norm (vector length).</p> <p>This normalization method scales each mode shape vector such that its Euclidean norm (vector length, 2-norm) becomes unity (length of 1). This is a mathematically simple and common method for general mode shape normalization, especially when focusing on the shape itself rather than physical scaling. Works for both real and complex mode shapes.</p> Math: <p>For a mode shape :math:<code>\\vec{\\Phi}_r</code>, the normalized mode shape :math:<code>\\vec{\\Phi}_{r, normalized}</code> is:</p> <p>.. math::     \\vec{\\Phi}_{r, normalized} = \\frac{\\vec{\\Phi}_r}{||\\vec{\\Phi}_r||_2}</p> <p>Where :math:<code>||\\vec{\\Phi}_r||_2</code> is the Euclidean norm (2-norm) of the mode shape vector.</p> <p>Parameters:</p> Name Type Description Default <code>modeshape</code> <code>ndarray</code> <p>Single modeshape [n_dof] or set of modeshapes [n_modes x n_dof]. Can be real or complex-valued.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Normalized modeshape(s) with the same shape as input. Each mode shape vector will have unit length (2-norm = 1).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If modeshape has incorrect dimensions</p> Source code in <code>postmodal/manipulation/normalize.py</code> <pre><code>def normalize_modeshape_unit_norm_vector_length(modeshape: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Normalize a single modeshape or set of modeshapes to unit norm (vector length).\n\n    This normalization method scales each mode shape vector such that its Euclidean norm (vector length, 2-norm)\n    becomes unity (length of 1). This is a mathematically simple and common method for general mode shape normalization,\n    especially when focusing on the shape itself rather than physical scaling. Works for both real and complex mode shapes.\n\n    Math:\n    -----\n    For a mode shape :math:`\\\\vec{\\\\Phi}_r`, the normalized mode shape :math:`\\\\vec{\\\\Phi}_{r, normalized}` is:\n\n    .. math::\n        \\\\vec{\\\\Phi}_{r, normalized} = \\\\frac{\\\\vec{\\\\Phi}_r}{||\\\\vec{\\\\Phi}_r||_2}\n\n    Where :math:`||\\\\vec{\\\\Phi}_r||_2` is the Euclidean norm (2-norm) of the mode shape vector.\n\n    Parameters\n    ----------\n    modeshape : np.ndarray\n        Single modeshape [n_dof] or set of modeshapes [n_modes x n_dof].\n        Can be real or complex-valued.\n\n    Returns\n    -------\n    np.ndarray\n        Normalized modeshape(s) with the same shape as input.\n        Each mode shape vector will have unit length (2-norm = 1).\n\n    Raises\n    ------\n    ValueError\n        If modeshape has incorrect dimensions\n    \"\"\"\n    ModalValidator.validate(modeshape)\n\n    if modeshape.ndim == 1:\n        norm_val = np.linalg.norm(modeshape)\n        return modeshape / norm_val if norm_val != 0 else modeshape\n\n    # modeshape.ndim == 2\n    norms = np.linalg.norm(modeshape, axis=1)\n    return np.where(norms[:, np.newaxis] != 0, modeshape / norms[:, np.newaxis], modeshape)\n</code></pre>"},{"location":"modules/#postmodal.manipulation.normalize_phase","title":"<code>normalize_phase(modeshape: NDArray[np.complex128], method: str = 'reference', reference_dof: int | None = None) -&gt; NDArray[np.complex128]</code>","text":"<p>Normalize the phase of a modeshape.</p> <p>This function normalizes the phase of a modeshape using one of several methods: - \"reference\": Align phase to a reference DOF - \"unwrap\": Unwrap phase to ensure continuity - \"both\": Apply both reference alignment and unwrapping</p> <p>Parameters:</p> Name Type Description Default <code>modeshape</code> <code>ndarray</code> <p>Complex modeshape array [n_dof]</p> required <code>method</code> <code>str</code> <p>Phase normalization method, by default \"reference\"</p> <code>'reference'</code> <code>reference_dof</code> <code>Optional[int]</code> <p>Index of the reference DOF for reference method, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Phase-normalized modeshape [n_dof]</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If method is not one of [\"reference\", \"unwrap\", \"both\"]</p> Source code in <code>postmodal/manipulation/phase.py</code> <pre><code>def normalize_phase(\n    modeshape: NDArray[np.complex128],\n    method: str = \"reference\",\n    reference_dof: int | None = None,\n) -&gt; NDArray[np.complex128]:\n    \"\"\"Normalize the phase of a modeshape.\n\n    This function normalizes the phase of a modeshape using one of several methods:\n    - \"reference\": Align phase to a reference DOF\n    - \"unwrap\": Unwrap phase to ensure continuity\n    - \"both\": Apply both reference alignment and unwrapping\n\n    Parameters\n    ----------\n    modeshape : np.ndarray\n        Complex modeshape array [n_dof]\n    method : str, optional\n        Phase normalization method, by default \"reference\"\n    reference_dof : Optional[int], optional\n        Index of the reference DOF for reference method, by default None\n\n    Returns\n    -------\n    np.ndarray\n        Phase-normalized modeshape [n_dof]\n\n    Raises\n    ------\n    ValueError\n        If method is not one of [\"reference\", \"unwrap\", \"both\"]\n    \"\"\"\n    if method not in [\"reference\", \"unwrap\", \"both\"]:\n        raise ValueError('method must be one of [\"reference\", \"unwrap\", \"both\"]')\n\n    result = modeshape.copy()\n\n    if method in [\"reference\", \"both\"]:\n        result = align_phase(result, reference_dof)\n\n    if method in [\"unwrap\", \"both\"]:\n        result = unwrap_phase(result)\n\n    return result\n</code></pre>"},{"location":"modules/#postmodal.manipulation.optimize_conversion","title":"<code>optimize_conversion(modeshape: np.ndarray, method: str = 'phase', reference_dof: int | None = None) -&gt; tuple[np.ndarray, float, float]</code>","text":"<p>Optimize the conversion of a complex modeshape to real.</p> <p>This function finds the optimal real-valued modeshape by minimizing the conversion error. It tries different reference DOFs and returns the one with the smallest error.</p> <p>Parameters:</p> Name Type Description Default <code>modeshape</code> <code>ndarray</code> <p>Complex modeshape array [n_dof]</p> required <code>method</code> <code>str</code> <p>Conversion method, by default \"phase\"</p> <code>'phase'</code> <code>reference_dof</code> <code>Optional[int]</code> <p>Initial reference DOF to try, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[ndarray, float, float]</code> <p>Tuple containing (optimal_modeshape, magnitude_error, phase_error) - optimal_modeshape: Best real-valued modeshape - magnitude_error: Magnitude error for optimal conversion - phase_error: Phase error for optimal conversion</p> Source code in <code>postmodal/manipulation/complex_to_real.py</code> <pre><code>def optimize_conversion(\n    modeshape: np.ndarray,\n    method: str = \"phase\",\n    reference_dof: int | None = None,\n) -&gt; tuple[np.ndarray, float, float]:\n    \"\"\"Optimize the conversion of a complex modeshape to real.\n\n    This function finds the optimal real-valued modeshape by minimizing\n    the conversion error. It tries different reference DOFs and returns\n    the one with the smallest error.\n\n    Parameters\n    ----------\n    modeshape : np.ndarray\n        Complex modeshape array [n_dof]\n    method : str, optional\n        Conversion method, by default \"phase\"\n    reference_dof : Optional[int], optional\n        Initial reference DOF to try, by default None\n\n    Returns\n    -------\n    tuple[np.ndarray, float, float]\n        Tuple containing (optimal_modeshape, magnitude_error, phase_error)\n        - optimal_modeshape: Best real-valued modeshape\n        - magnitude_error: Magnitude error for optimal conversion\n        - phase_error: Phase error for optimal conversion\n    \"\"\"\n    n_dof = len(modeshape)\n    best_error = float(\"inf\")\n    # Initialize with a default value to ensure we never return None\n    best_modeshape = complex_to_real(modeshape, method, reference_dof)\n    best_mag_error = 0.0\n    best_phase_error = 0.0\n\n    # Try each DOF as reference\n    for ref in range(n_dof):\n        real_phi = complex_to_real(modeshape, method, ref)\n        mag_error, phase_error = calculate_conversion_error(modeshape, real_phi)\n        total_error = mag_error + phase_error\n\n        if total_error &lt; best_error:\n            best_error = total_error\n            best_modeshape = real_phi\n            best_mag_error = mag_error\n            best_phase_error = phase_error\n\n    return best_modeshape, best_mag_error, best_phase_error\n</code></pre>"},{"location":"modules/#postmodal.manipulation.unwrap_phase","title":"<code>unwrap_phase(modeshape: NDArray[np.complex128], axis: int | None = None) -&gt; NDArray[np.complex128]</code>","text":"<p>Unwrap the phase of a modeshape.</p> Source code in <code>postmodal/manipulation/phase.py</code> <pre><code>def unwrap_phase(\n    modeshape: NDArray[np.complex128],\n    axis: int | None = None,\n) -&gt; NDArray[np.complex128]:\n    \"\"\"Unwrap the phase of a modeshape.\"\"\"\n    # Original phases\n    phase = np.angle(modeshape)\n\n    # Unwrap the phases - ensure we're using the correct axis\n    axis_to_use = 0 if axis is None and phase.ndim &gt; 0 else axis if axis is not None else -1\n\n    unwrapped_phase = np.unwrap(phase, axis=axis_to_use)\n\n    # Important: After unwrapping, phases may be outside [-\u03c0, \u03c0]\n    # but we need to convert back to complex numbers\n    magnitude = np.abs(modeshape)\n    result = magnitude * np.exp(1j * unwrapped_phase)\n\n    return cast(NDArray[np.complex128], result)\n</code></pre>"},{"location":"modules/#visualization","title":"Visualization","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"modules/#postmodal.visualization","title":"<code>postmodal.visualization</code>","text":"<p>MAC matrix visualization module.</p>"},{"location":"modules/#postmodal.visualization.plot_mac_matrix","title":"<code>plot_mac_matrix(mac_matrix: np.ndarray, x_tick_labels: list[str], y_tick_labels: list[str], text_color_variable: bool = True, invert_scale: bool = False, ax: Axes | None = None) -&gt; tuple[Figure, Axes]</code>","text":"<p>Plot the MAC matrix.</p> <p>Parameters:</p> Name Type Description Default <code>mac_matrix</code> <code>ndarray</code> <p>MAC matrix [n_modes_1 x n_modes_2]</p> required <code>x_tick_labels</code> <code>list[str]</code> <p>Labels for x-axis ticks (columns of the MAC matrix)</p> required <code>y_tick_labels</code> <code>list[str]</code> <p>Labels for y-axis ticks (rows of the MAC matrix)</p> required <code>text_color_variable</code> <code>bool</code> <p>Whether to vary text color based on MAC value, by default True</p> <code>True</code> <code>invert_scale</code> <code>bool</code> <p>Whether to invert the colormap scale, by default False</p> <code>False</code> <code>ax</code> <code>Optional[Axes]</code> <p>Matplotlib axes to plot on, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Figure, Axes]</code> <p>The figure and axes objects</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dimensions of inputs are incompatible</p> Source code in <code>postmodal/visualization.py</code> <pre><code>def plot_mac_matrix(\n    mac_matrix: np.ndarray,\n    x_tick_labels: list[str],\n    y_tick_labels: list[str],\n    text_color_variable: bool = True,\n    invert_scale: bool = False,\n    ax: Axes | None = None,\n) -&gt; tuple[Figure, Axes]:\n    \"\"\"Plot the MAC matrix.\n\n    Parameters\n    ----------\n    mac_matrix : np.ndarray\n        MAC matrix [n_modes_1 x n_modes_2]\n    x_tick_labels : list[str]\n        Labels for x-axis ticks (columns of the MAC matrix)\n    y_tick_labels : list[str]\n        Labels for y-axis ticks (rows of the MAC matrix)\n    text_color_variable : bool, optional\n        Whether to vary text color based on MAC value, by default True\n    invert_scale : bool, optional\n        Whether to invert the colormap scale, by default False\n    ax : Optional[Axes], optional\n        Matplotlib axes to plot on, by default None\n\n    Returns\n    -------\n    tuple[Figure, Axes]\n        The figure and axes objects\n\n    Raises\n    ------\n    ValueError\n        If dimensions of inputs are incompatible\n    \"\"\"\n    if ax is None:\n        fig, ax = plt.subplots()\n    else:\n        fig = cast(Figure, ax.figure)\n\n    # Validate dimensions\n    if len(x_tick_labels) != mac_matrix.shape[1]:\n        raise ValueError(\"Number of x_tick_labels must match number of columns in mac_matrix\")\n    if len(y_tick_labels) != mac_matrix.shape[0]:\n        raise ValueError(\"Number of y_tick_labels must match number of rows in mac_matrix\")\n\n    # Set up colormap\n    cmap = \"Greys_r\" if invert_scale else \"Greys\"\n    norm = Normalize(vmin=0, vmax=1)\n\n    # Plot matrix\n    _ = ax.matshow(mac_matrix, norm=norm, cmap=cmap)\n\n    # Configure grid\n    ax.grid(False, which=\"major\")\n    ax.xaxis.set_minor_locator(FixedLocator([x + 0.5 for x in range(mac_matrix.shape[1] - 1)]))\n    ax.yaxis.set_minor_locator(FixedLocator([x + 0.5 for x in range(mac_matrix.shape[0] - 1)]))\n\n    # Configure ticks and labels\n    ax.xaxis.set_major_locator(FixedLocator(range(mac_matrix.shape[1])))\n    ax.set_xticklabels(x_tick_labels, rotation=90)\n    ax.yaxis.set_major_locator(FixedLocator(range(mac_matrix.shape[0])))\n    ax.yaxis.set_major_formatter(FixedFormatter(y_tick_labels))\n\n    # Add grid lines\n    ax.grid(True, which=\"minor\", color=\"0.7\", linestyle=\"-\", linewidth=1.5)\n\n    # Configure labels\n    ax.xaxis.set_label_position(\"top\")\n    # ax.set(xlabel=\"Numerical modes\", ylabel=\"OMA modes\")\n\n    # Add text annotations\n    def _get_text_color(value: float) -&gt; str:\n        \"\"\"Return text color based on MAC value.\n\n        Parameters\n        ----------\n        value : float\n            The MAC value to determine text color for\n\n        Returns\n        -------\n        str\n            The text color as a string\n        \"\"\"\n        if invert_scale:\n            return \"0.8\" if value &lt; 0.4 else \"0.2\"\n        else:\n            return \"0.8\" if value &gt; 0.6 else \"0.2\"\n\n    for irow in range(mac_matrix.shape[0]):\n        for jcol in range(mac_matrix.shape[1]):\n            ax.text(\n                jcol + 0.0,\n                irow + 0.0,\n                f\"{mac_matrix[irow, jcol]:.2f}\",\n                color=(\"C0\" if not text_color_variable else _get_text_color(mac_matrix[irow, jcol])),\n                size=10,\n                fontweight=\"bold\",\n                va=\"center\",\n                ha=\"center\",\n            )\n\n    return fig, ax\n</code></pre>"},{"location":"modules/#postmodal.visualization.plot_modeshape_complexity","title":"<code>plot_modeshape_complexity(modeshape: np.ndarray, ax: PolarAxes | None = None) -&gt; tuple[Figure, PolarAxes]</code>","text":"<p>Plot the complexity of a modeshape using a polar Argand diagram.</p> <p>Parameters:</p> Name Type Description Default <code>modeshape</code> <code>ndarray</code> <p>Complex modeshape vector</p> required <code>ax</code> <code>Optional[PolarAxes]</code> <p>Matplotlib polar axes to plot on, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Figure, PolarAxes]</code> <p>The figure and axes containing the complexity plot</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided axes is not a polar projection</p> Source code in <code>postmodal/visualization.py</code> <pre><code>def plot_modeshape_complexity(\n    modeshape: np.ndarray,\n    ax: PolarAxes | None = None,\n) -&gt; tuple[Figure, PolarAxes]:\n    \"\"\"Plot the complexity of a modeshape using a polar Argand diagram.\n\n    Parameters\n    ----------\n    modeshape : np.ndarray\n        Complex modeshape vector\n    ax : Optional[PolarAxes], optional\n        Matplotlib polar axes to plot on, by default None\n\n    Returns\n    -------\n    tuple[Figure, PolarAxes]\n        The figure and axes containing the complexity plot\n\n    Raises\n    ------\n    ValueError\n        If the provided axes is not a polar projection\n    \"\"\"\n    if ax is None:\n        fig = plt.figure()\n        ax = cast(PolarAxes, fig.add_subplot(111, projection=\"polar\"))\n    else:\n        fig = cast(Figure, ax.get_figure())\n        if ax.name != \"polar\":\n            raise ValueError(\"Axes must be polar projection\")\n\n    # Calculate magnitude and phase\n    magnitude = np.abs(modeshape)\n    phase = np.angle(modeshape, deg=True)\n\n    # Plot the complex mode shape points\n    ax.scatter(np.radians(phase), magnitude, marker=\"o\")\n\n    # Add lines from origin to each point\n    for i in range(len(modeshape)):\n        ax.plot([0, np.radians(phase[i])], [0, magnitude[i]], \"k--\", alpha=0.3)\n\n    # Add grid\n    ax.grid(True)\n\n    # Set the position of the radial tick labels to 90 degrees\n    ax.set_rlabel_position(90)\n\n    return fig, ax\n</code></pre>"},{"location":"modules/#postmodal.visualization.plot_modeshape_complexity_grid","title":"<code>plot_modeshape_complexity_grid(frequencies: np.ndarray, modeshapes: np.ndarray, figsize: tuple[float, float] | None = None, n_row: int | None = None, n_col: int | None = None, hspace: float = 0.4, wspace: float = 0.4) -&gt; tuple[Figure, np.ndarray]</code>","text":"<p>Plot multiple modeshape complexity plots in a grid layout.</p> <p>Parameters:</p> Name Type Description Default <code>frequencies</code> <code>ndarray</code> <p>Array of frequencies for each mode</p> required <code>modeshapes</code> <code>ndarray</code> <p>Array of complex modeshapes</p> required <code>figsize</code> <code>Optional[tuple[float, float]]</code> <p>Figure size, by default None</p> <code>None</code> <code>n_row</code> <code>Optional[int]</code> <p>Number of rows in grid, by default None</p> <code>None</code> <code>n_col</code> <code>Optional[int]</code> <p>Number of columns in grid, by default None</p> <code>None</code> <code>hspace</code> <code>float</code> <p>Horizontal spacing between plots, by default 0.4</p> <code>0.4</code> <code>wspace</code> <code>float</code> <p>Vertical spacing between plots, by default 0.4</p> <code>0.4</code> <p>Returns:</p> Type Description <code>tuple[Figure, ndarray]</code> <p>The figure and array of axes containing the complexity plots</p> Source code in <code>postmodal/visualization.py</code> <pre><code>def plot_modeshape_complexity_grid(\n    frequencies: np.ndarray,\n    modeshapes: np.ndarray,\n    figsize: tuple[float, float] | None = None,\n    n_row: int | None = None,\n    n_col: int | None = None,\n    hspace: float = 0.4,\n    wspace: float = 0.4,\n) -&gt; tuple[Figure, np.ndarray]:\n    \"\"\"Plot multiple modeshape complexity plots in a grid layout.\n\n    Parameters\n    ----------\n    frequencies : np.ndarray\n        Array of frequencies for each mode\n    modeshapes : np.ndarray\n        Array of complex modeshapes\n    figsize : Optional[tuple[float, float]], optional\n        Figure size, by default None\n    n_row : Optional[int], optional\n        Number of rows in grid, by default None\n    n_col : Optional[int], optional\n        Number of columns in grid, by default None\n    hspace : float, optional\n        Horizontal spacing between plots, by default 0.4\n    wspace : float, optional\n        Vertical spacing between plots, by default 0.4\n\n    Returns\n    -------\n    tuple[Figure, np.ndarray]\n        The figure and array of axes containing the complexity plots\n    \"\"\"\n    n_modes = len(frequencies)\n\n    if n_row is None or n_col is None:\n        n_row, n_col = _calculateGridLayout(n_modes)\n\n    if figsize is None:\n        figsize = (4 * n_col, 4 * n_row)\n\n    fig, axs = plt.subplots(\n        figsize=figsize,\n        nrows=n_row,\n        ncols=n_col,\n        gridspec_kw={\"hspace\": hspace, \"wspace\": wspace},\n        sharex=False,\n        sharey=False,\n        subplot_kw={\"projection\": \"polar\"},\n    )\n\n    for i in range(n_modes):\n        ax = cast(PolarAxes, axs.flatten()[i])\n        _, _ = plot_modeshape_complexity(modeshapes[i], ax=ax)\n        ax.set_title(f\"{frequencies[i]:.2f} Hz\")\n\n    return fig, axs\n</code></pre>"}]}